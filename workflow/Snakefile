configfile: "config/test.yaml" # test

out_prefix = config["out_prefix"]
log_prefix = config["log_prefix"]
temp_prefix = config["temp_prefix"]

max_threads = config["max_threads"]
seed = config["seed"]

genome = config["genome"]

atac_samples = config["atac_samples"]

# test
fragments_prefix = config["fragments_prefix"] 
fragments_suffix = config["fragments_suffix"] 

def get_input_fastq_r1(wildcards):
    return config["fastq"][wildcards.sample]["R1"]

def get_input_fastq_r2(wildcards):
    return config["fastq"][wildcards.sample]["R2"]

rule all:
    input:
        directory(out_prefix + "archr_build/project")

"""
Read alignment (Bowtie2 aligner)
"""
rule align_bowtie2:
    input:
        fastq1=get_input_fastq_r1,
        fastq2=get_input_fastq_r2,
        bwt2_idx=config["bwt2"]["index"] #TODO: Add to config
    output:
        bam_raw=(out_prefix + "align/raw.bam"),
        bam_no_mito=(out_prefix + "align/non_mito.bam"),
        flagstat_qc=(out_prefix + "align/flagstat_raw.qc")
    params:
        multimapping=config["bwt2"]["multimapping"] #TODO: Add to config
    log:
        log_prefix + "align/bwt2.log",
    threads:
        max_threads
    shell:
        "./scripts/align.sh {input.fastq1} {input.fastq2} {input.bwt2_idx}" 
        "{params.multimapping}" 
        "{output.bam_raw} {output.bam_no_mito} {output.flagstat_qc}"
        "{log} {threads}"

"""
Compute fraction of mitochondrial reads
"""
rule frac_mito:
    #TODO

"""
Post-alignment filtering
"""
rule dedup_bam:
    input:
        out_prefix + "raw.bam"
    output:
        bam=(out_prefix + "align/final.bam"),
        ind=(out_prefix + "align/final.bam.bai"),
        flagstat=(out_prefix + "align/flagstat_final.qc"),
        dup=(out_prefix + "align/dup.qc"),
        pbc=(out_prefix + "align/pbc.qc"),
        filter_temp_prefix=temp(directory(temp_prefix + "align/filter/"))
    threads:
        max_threads
    shell:
        f"scripts_sh/dedup_bam_{'pe' if is_paired_end else 'se'}.sh"
        " {input} {output.bam} {output.ind} {output.flagstat} {output.dup} {output.pbc} {output.filter_temp_prefix} {threads}"


"""
Preliminary ArchR analyses
"""
rule build_archr_project:
    input:
        expand(fragments_prefix + "{sample}" + fragments_suffix, sample=atac_samples)
    output:
        arrows_temp_dir=temp(directory(temp_prefix + "archr_build/arrows_init")),
        qc_dir=directory(out_prefix + "archr_build/qc"),
        project_dir=directory(out_prefix + "archr_build/project")
    params:
        sample_names=atac_samples,
        seed=seed,
        genome=genome
    log:
        log_dir=(log_prefix + "archr_build"),
        arrow_create=(log_prefix + "archr_build/arrow_create.log"),
        doublets=(log_prefix + "archr_build/doublets.log"),
        lsi=(log_prefix + "archr_build/lsi.log"),
        cluster=(log_prefix + "archr_build/cluster.log"),
        marker_genes=(log_prefix + "archr_build/marker_genes.log"),
        pseudobulk_rep=(log_prefix + "archr_build/pseudobulk_rep.log"),
        peak_call=(log_prefix + "archr_build/peak_call.log"),
        peak_matrix=(log_prefix + "archr_build/peak_matrix.log"),
        marker_peaks=(log_prefix + "archr_build/marker_peaks.log"),
        fetch_motif=(log_prefix + "archr_build/fetch_motif.log"),
        enr_motif=(log_prefix + "archr_build/enr_motif.log"),
        fetch_tf=(log_prefix + "archr_build/fetch_tf.log"),
        enr_tf=(log_prefix + "archr_build/enr_tf.log"),
        save=(log_prefix + "archr_build/save.log"),
    threads:
        max_threads
    script:
        "scripts/build_archr_project.R"